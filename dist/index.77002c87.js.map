{"mappings":"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","sources":["js/extractFeatures.js"],"sourcesContent":["const sampleRate = 22050;\r\nconst frameSize = 2048;\r\nconst hopLength = 512;\r\n\r\nconst midiPitches = 128;\r\nconst pitchClasses = 12;\r\nconst pitchRef = 69;\r\nconst freqRef = 440;\r\n\r\nlet ctx = new (window.AudioContext || window.webkitAudioContext)({sampleRate: `${sampleRate}`});\r\nctx.sampleRate = sampleRate;\r\n\r\n// Audio feature extraction pipeline\r\nlet analyseAudio = async (URL) => {\r\n    ctx.resume();\r\n\r\n    let signal = await x(URL);\r\n    let magSpec = await Y(signal);\r\n    let logComp = await logCompression(magSpec, 0.01).array();\r\n    let logSpec = await computeSpecLogFreq(logComp, sampleRate, frameSize, midiPitches);\r\n    let C = await computeChroma(logSpec, pitchClasses, midiPitches);\r\n    let normC = await normalizeFeature(C, 0.001);\r\n\r\n    /* let plot = [\r\n        {\r\n            z: logSpec,\r\n            type: 'heatmap',\r\n            colorscale: 'Greys'\r\n        }\r\n    ];\r\n    let plotAudio = chromaHeatMap(plot, 'Spectrum X_n');\r\n    Plotly.newPlot('audiofeatures', plot, plotAudio['layout'], {scrollZoom: false}); */\r\n\r\n    // Save some resources\r\n    signal = null;\r\n    magSpec = null;\r\n    logComp = null;\r\n    logSpec = null;\r\n    C = null;\r\n    ctx.suspend();\r\n\r\n    return normC;\r\n}\r\n\r\n// Extract audio signal\r\nlet x = async (URL) => {\r\n    console.log(\"Step: Decoding\");\r\n    return fetch(URL)\r\n    .then(data => data.arrayBuffer())\r\n    .then(arrayBuffer => ctx.decodeAudioData(arrayBuffer))\r\n    .then(audioData => {\r\n        console.log(`--Audio duration: ${convertHMS(audioData.length/sampleRate)} minutes`)\r\n        return audioData.getChannelData(0)\r\n    })\r\n        \r\n}\r\n\r\n// Compute magnitude power spectrogram, return Promise\r\nlet Y = async x => {\r\n    console.log(\"Step: Magnitude spectrogram\");\r\n    let result = tf.tidy(() => tf.square(tf.abs(tf.transpose(tf.signal.stft(tf.tensor1d(x), frameSize, hopLength, frameSize, tf.signal.hannWindow)))));\r\n    return result.array();\r\n}\r\n\r\n// Compute log-frequency spectrogram\r\n// Y = linear frequency magnitude spectrogram\r\nlet computeSpecLogFreq = async (Y, sampleRate, frameSize, midiPitches) => {\r\n    console.log(\"Step: Log-frequency spectrogram\");\r\n\r\n    // Since the number of columns isn't fixed, declaring the rows is enough (else, columns = frame count) \r\n    let Y_LF = new Array(midiPitches).fill(0);\r\n\r\n    // Extract the corresponding k-th bins with k âˆˆ P(p) from the STFT Y\r\n    // and sum them up\r\n    for (let p = 0; p < midiPitches; p++) {\r\n        let k = poolPitch(p, sampleRate, frameSize, pitchRef, freqRef);\r\n        let lowerK = k[0];\r\n        let upperK = k.at(-1)+1;\r\n        let slicedY = await Y.slice(lowerK, upperK);\r\n        Y_LF[p] = summedByCol(slicedY);\r\n    }\r\n    return Y_LF;\r\n}\r\n\r\n// Compute the chroma\r\n// Y_LF = log-freq spectrogram\r\n// pitchClasses = number of pitch classes, e.g. {C, C#, D, D#, E, F, F#, G, G#, A, A#, B}\r\nlet computeChroma = async (Y_LF, pitchClasses) => {\r\n    console.log(\"Step: Chroma\");\r\n\r\n    let C = [];\r\n\r\n    // Sum up all rows from the log-frequency spectrogram into their\r\n    // respective pitch classes\r\n    for (let c = 0; c < pitchClasses; c++) {\r\n        C[c] = summedByCol(Y_LF.filter((e, index) => index % pitchClasses == c));\r\n    }\r\n\r\n    // Normalize by the max coefficient\r\n    return await scaled(C, 1/await getMaxFromNDimArr(C));\r\n};\r\n\r\n// Normalize features\r\nlet normalizeFeature = async (X, threshhold) => {\r\n    console.log(\"Step: Normalize\");\r\n\r\n    const K = pitchClasses;   \r\n    const N = X[0].length;    // Frames\r\n    let normX = arrayFilled(K, N);\r\n    let v = 1 / Math.sqrt(K);\r\n\r\n    for (let n = 0; n < N; n++) {\r\n\r\n        let sumOfSquares = 0;\r\n        for(let k = 0; k < K; k++) {\r\n            sumOfSquares += X[k][n] ** 2;\r\n        }\r\n        let s = Math.sqrt(sumOfSquares);\r\n        if (s > threshhold) {\r\n            for(let k = 0; k < K; k++) {\r\n                normX[k][n] = X[k][n] / s;\r\n            }\r\n        } else {\r\n            for(let k = 0; k < K; k++) {\r\n                normX[k][n] = v;\r\n            }\r\n        }\r\n    }\r\n    return normX;\r\n}\r\n\r\n// Read the MIDI file\r\nasync function parseMIDI (file) {\r\n    console.log(\"Step: Parse MIDI\");\r\n\r\n    let currentMidi = null;\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onload = (e) => {\r\n        const midi = new Midi(e.target.result);\r\n        currentMidi = midi;\r\n        resolve(currentMidi);\r\n    };\r\n    reader.readAsArrayBuffer(file);\r\n    })\r\n}\r\n\r\n// Compute chroma from MIDI, all in one\r\nlet analyseMIDI = async (file) => {\r\n    console.log(\"Step: Analyse MIDI\");\r\n\r\n    let midi = await parseMIDI(file);\r\n\r\n    // At ratio = 1000, there would be a column for each ms, which makes the computation needlessly slow. \r\n    // Thus, this reduces the temporal resolution\r\n    let ratio = 1000 / 20;\r\n\r\n    // This defines the time grid resolution of the features\r\n    let C = arrayFilled(pitchClasses, Math.round(midi.duration * ratio));\r\n\r\n    // Get duration of the entire MIDI file\r\n    // console.log(midi);\r\n    console.log(`--MIDI duration: ${convertHMS(midi.duration)} minutes`);\r\n\r\n    let tracks = midi.tracks;\r\n    let totalTracksNum = midi.tracks.length;\r\n\r\n    for(let i = 0; i < totalTracksNum; i++) {\r\n        let trackNotesNum = tracks[i].notes.length;\r\n\r\n        for(let j = 0; j < trackNotesNum; j++) {\r\n            let currentTrackNote = tracks[i].notes[j];\r\n\r\n            // Readability\r\n            let pitch = currentTrackNote.midi % pitchClasses;\r\n            let noteOnTime = Math.round(currentTrackNote.time * ratio);\r\n            let durationNote = Math.round(currentTrackNote.duration * ratio);\r\n\r\n            // Add the notes in the feature matrix by their velocities (over all tracks)\r\n            let noteOffTime = noteOnTime+durationNote;\r\n            for(let k = noteOnTime; k < noteOffTime; k++) {\r\n                C[pitch][k] = C[pitch][k] + currentTrackNote.velocity;\r\n            }\r\n            \r\n            // Get info from each note\r\n            // console.log(`\r\n            //     MIDI: ${note.midi},\r\n            //     Time ms: ${Math.round(note.time * 1000)},\r\n            //     Duration ms: ${Math.round(note.duration * 1000)},\r\n            //     Pitch: ${note.pitch},\r\n            //     Velocity: ${note.velocity}\r\n            //     `);\r\n        }\r\n    }\r\n\r\n    // Save memory\r\n    midi = null;\r\n\r\n    // Return normalized chroma\r\n    return await normalizeFeature(C, 0.001);\r\n}"],"names":[],"version":3,"file":"index.77002c87.js.map","sourceRoot":"/__parcel_source_root/"}