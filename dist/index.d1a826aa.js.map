{"mappings":"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","sources":["js/dtw.js"],"sourcesContent":["// Calculate the DTW path for 2D time series X, Y\r\nlet dtw = async (X, Y) => {\r\n    let n = X[0].length;\r\n    let m = Y[0].length;\r\n    \r\n    // Local weights for the accumulated cost matrix D\r\n    let w = {d: 2, h: 1.5, v: 1.5};\r\n    console.log (\"Local weights w: \", w)\r\n    \r\n    // Get a global constrain region R, that encodes what portion of the\r\n    // cost matrix C will be calculated going forward. wsz = WindowSize\r\n    // This speeds up the computation, but comes at the risk of inaccuracy.\r\n    // MsDTW and MrMsDTW would be further advanced optimizations.\r\n    let R = await computeGlobalConstraintRegion(n, m, 0.8);\r\n    //console.log(\"Constraint region R:\\n\", R);\r\n    \r\n    let C = await costMatrix(math.transpose(X), math.transpose(Y), R);\r\n    let D = await computeAccumulatedCostMatrix(C, R, w);\r\n    let P = await computeOptimalWarpingPath(D);\r\n\r\n    console.log(\"-DTW distance DTW(X,Y) = \", D.at(-1).at(-1));\r\n\r\n    C, R = null;\r\n\r\n    return [P, D];\r\n}\r\n\r\n// Distance matrix between any 2 given 2D vectors that have the same number of rows\r\n// Metric: Cosine distance\r\n// Cost matrix C\r\nlet costMatrix = async (N, M, R) => {\r\n    console.log(\"Step: Cost matrix\");\r\n    let n = N.length;\r\n    let m = M.length;\r\n\r\n    let cosD = arrayFilled(n, m, Infinity);\r\n\r\n    for(let i = 0; i < n; i++) {\r\n        // Set boundary conditions from said constraint region R = Sakoe-Chiba band\r\n        for(let k = R[0][i], len = R[1][i]; k < len; k++) {\r\n            let ni = N[i];\r\n            let mk = M[k];\r\n            cosD[i][k] = 1 - (math.dot(ni, mk) / (math.norm(ni, 2) * math.norm(mk, 2)));\r\n        }\r\n    }\r\n    return cosD;\r\n}\r\n\r\n// Accumulated cost matrix D\r\nlet computeAccumulatedCostMatrix = async (C, R, w) => {\r\n    console.log(\"Step: Accumulated cost matrix\");\r\n    let n = C.length;\r\n\r\n    // Use constraint region R to determine which parts of the calculation can be left out\r\n    // R[0].findIndex(e => e > 0): First starting index R[0][i] where it doesn't touch the border of the matrix anymore\r\n    for(let i = 1, len = R[0].findIndex(e => e > 0); i < len; i++) {\r\n        C[i][0] = C[i-1][0] + ( C[i][0] * w['h'] );\r\n    }   \r\n\r\n    for(let j = 1, len = R[1][0]; j < len; j++) {\r\n        C[0][j] = C[0][j-1] + ( C[0][j] * w['v'] );\r\n    }\r\n\r\n    // Fill rest of the matrix w.r.t. R\r\n    for(let i = 1; i < n; i++) {\r\n        for(let k = 1, len = R[1][i]; k < len; k++) {\r\n            let C_ik = C[i][k];\r\n            C[i][k] = Math.min( C[i-1][k] + ( w['h'] * C_ik ), \r\n                                C[i][k-1] + ( w['v'] * C_ik ), \r\n                                C[i-1][k-1] + ( w['d'] * C_ik ) );\r\n            /* console.log(\"D[\",i,\"][\",k,\"]: \", D[i][k], \" = \\nMath.min(\\nC[\",i-1,\"][\",k,\"]: \", C[i-1][k], \" + C[\",i,\"][\",k,\"]: \", C[i][k], \"\\n( = \",C[i-1][k]+C[i][k],\"),\\nC[\",i,\"][\",k-1,\"]: \", C[i][k-1], \" + C[\",i,\"][\",k,\"]: \", C[i][k], \"\\n( = \",C[i][k-1]+C[i][k],\"),\\nC[\",i-1,\"][\",k-1,\"]: \", C[i-1][k-1], \" + C[\",i,\"][\",k,\"]: \", C[i][k], \"\\n( = \",C[i-1][k-1]+C[i][k],\") \\n)\") */\r\n        }            \r\n    }\r\n    return C;\r\n}\r\n\r\n// Optimal warping path P from an accumulated cost matrix D\r\nlet computeOptimalWarpingPath = async (D) => {\r\n    console.log(\"Step: Optimal warping path\");\r\n    const N = D.length;\r\n    const M = D[0].length;\r\n\r\n    let n = N-1;\r\n    let m = M-1;\r\n    let P = [[n, m]];\r\n    let cell;\r\n\r\n    while(n > 0 || m > 0) {\r\n        if (n == 0) {\r\n            cell = [0, m-1];\r\n        } else if (m == 0) {\r\n            cell = [n-1, 0];\r\n        } else {\r\n            let d_n1m1 = D[n-1][m-1];\r\n            let d_n1m = D[n-1][m];\r\n            let val = Math.min( d_n1m1, \r\n                                d_n1m, \r\n                                D[n][m-1] );\r\n            if (val == d_n1m1) {\r\n                cell = [n-1, m-1];\r\n            } else if (val == d_n1m) {\r\n                cell = [n-1, m];\r\n            } else {\r\n                cell = [n, m-1];\r\n            }\r\n        }\r\n        P.push(cell);\r\n        n = cell[0];\r\n        m = cell[1];\r\n    }\r\n\r\n    P.reverse();\r\n    return P;\r\n}"],"names":[],"version":3,"file":"index.d1a826aa.js.map","sourceRoot":"/__parcel_source_root/"}