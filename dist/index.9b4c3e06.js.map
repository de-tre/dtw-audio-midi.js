{"mappings":"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","sources":["js/helpers.js"],"sourcesContent":["// Functions that are used inside others \r\n\r\n// <Some overview statistics\r\nconsole.log(`Sampling rate: ${sampleRate}`);\r\nconsole.log(`Frame size: ${frameSize}`);\r\nconsole.log(`Hop length: ${hopLength}`);\r\nconsole.log(`STFT frequency resolution (in Hz): ${Math.round(((sampleRate/frameSize) + Number.EPSILON) * 100) / 100}`);\r\n// [76, 64, 52, 40, 39, 38].forEach((value) => \r\n//     console.log(`Set P(${value}) = ${poolPitch(value, sampleRate, frameSize, pitchRef, freqRef)}`));\r\n\r\n\r\n// Calculate frequency from MIDI pitch\r\nlet fPitch = (p, pitchRef, freqRef) => 2 ** ((p-pitchRef) / pitchClasses) * freqRef;\r\n\r\n// Pool the pitches such that P(p):={k: fPitch(p-0.5) <= fPitch(k) < fPitch(p+0.5)}\r\nlet poolPitch = (p, sampleRate, frameSize, pitchRef, freqRef) => {\r\n    \r\n    // Calculate the border frequencies \r\n    let lowerPitch = fPitch(p - 0.5, pitchRef, freqRef);\r\n    let upperPitch = fPitch(p + 0.5, pitchRef, freqRef);\r\n    \r\n    // Array with k-indeces ranging from 0 to (frameSize/2) + 1\r\n    let k = [...Array((frameSize / 2) + 1).keys()];\r\n    \r\n    // Array with center frequency for each k\r\n    let kFreq = k.map(x => (x * sampleRate) / frameSize);\r\n    \r\n    // Storing P(p) in a variable and return the corresponding k indeces\r\n    let mask = kFreq.map(x => ((lowerPitch <= x) && (x < upperPitch)));\r\n    return k.filter(e => mask[e]);\r\n};\r\n\r\n// Logarithmic compression => log(1 + gamma * v)\r\nlet logCompression = (v, gamma) => tf.log(tf.add(tf.mul(tf.tensor(gamma), v), tf.tensor(1)));\r\n\r\n// Define a global constraint region, to which calculations are restricted\r\n// To speed up computation. This particular configuration is called Sakoe-Chiba band\r\nlet computeGlobalConstraintRegion = async (lengthN, lengthM, windowSize) => {\r\n    let lowerBound;\r\n    let upperBound;\r\n    let bw = windowSize < 1 ? ((windowSize*lengthM)/2)+1 : windowSize;\r\n    let R = arrayFilled(2, lengthN);\r\n\r\n    for (let i = 0; i < lengthN; i++) {\r\n        let diagY = i/(lengthN-1)*lengthM;\r\n\r\n        lowerBound = Math.round(diagY-bw);\r\n        upperBound = Math.round(diagY+bw);\r\n\r\n        if ( lowerBound < 0) lowerBound = 0;\r\n        if ( upperBound <= 0) upperBound = bw;\r\n        if ( lowerBound >= lengthM) lowerBound = lengthM-bw;\r\n        if ( upperBound > lengthM) upperBound = lengthM;\r\n\r\n        R[0][i] = lowerBound;\r\n        R[1][i] = upperBound;\r\n    }\r\n    return R;\r\n}\r\n\r\n// Create array filled with zeros\r\nlet arrayFilled = (rows, cols, val) => {\r\n    val = (typeof val !== 'undefined') ? val: 0;\r\n    let filledArr = Array(rows);\r\n    for(let i = 0; i < rows; i++) {\r\n        filledArr[i] = Array(cols).fill(val);\r\n    }\r\n    return filledArr;\r\n}\r\n\r\n// Merge all rows from a 2D array to one summed row\r\nlet summedByCol = (arr) => arr.reduce((r, a) => {\r\n    let al = a.length;\r\n    for(let i = 0; i < al; i++) {\r\n        r[i] = (r[i] || 0) + a[i];\r\n    }\r\n    return r;\r\n}, []);\r\n\r\n// Max value in 2D matrix\r\nlet getMaxFromNDimArr = async (arr) => {\r\n    let arrL = arr.length;\r\n    let arrPulledApart = [];\r\n    for (let i = 0; i < arrL; i++) {\r\n        arrPulledApart = arrPulledApart.concat(arr[i]);\r\n    }\r\n    let max = arrPulledApart.reduce((pv, cv) => Math.max(pv, cv), -Infinity);\r\n    return max;\r\n} \r\n// Multiply 2D array by a scalar\r\nlet scaled = async (arr, scalar) => {\r\n    for (let r = 0; r < arr.length; r++) {\r\n        arr[r] = arr[r].map(x => x * scalar);\r\n    }\r\n    return arr;\r\n}\r\n\r\n// Square 2D array\r\nlet square = (arr) => {\r\n    let squaredArr = [];\r\n    let dim0Length = arr.length;\r\n    let dim1Length = arr[0].length;\r\n    for (let i = 0; i < dim0Length; i++) {\r\n        let row = [];\r\n        for (let j = 0; j < dim1Length; j++) {\r\n            row.push(arr[i][j] ** 2);\r\n        }\r\n        squaredArr.push(row);\r\n    }\r\n  return squaredArr;\r\n}\r\n\r\nlet chromaHeatMap = (data, title) => {\r\n    return {\r\n            plot: [{\r\n                y: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],\r\n                z: data,\r\n                name: title,\r\n                type: 'heatmap',\r\n                colorscale: 'Greys',\r\n                marker: {\r\n                    color: '#C8A2C8',\r\n                    line: {\r\n                        width: 2.5\r\n                    }\r\n                }\r\n            }],\r\n            layout: {\r\n                autosize: true,\r\n                title: {\r\n                    font: {\r\n                        size: 24,\r\n                        color: '#e8e6e3',\r\n                    },\r\n                    text: title,\r\n                },\r\n                xaxis: {\r\n                    ticks: '',\r\n                    side: 'bottom'\r\n                  },\r\n                yaxis: {\r\n                    ticks: '',\r\n                    ticksuffix: ' ',\r\n                },\r\n                paper_bgcolor: '#222',\r\n                plot_bgcolor: '#222',\r\n                font: {\r\n                    color: '#eee'\r\n                }\r\n            },\r\n        }\r\n} \r\n\r\nlet costPathPlot = (costMat, path) => {\r\n    let layout = {\r\n        title: {\r\n            font: {\r\n                size: 24,\r\n                color: '#e8e6e3',\r\n            },\r\n            text: '$\\\\text{Accumulated cost matrix }D\\\\text{, }\\\\\\\\\\\\text{Optimal warping path }P^{*}_{R}$'\r\n        },\r\n        xaxis: {\r\n            title: '$N$',\r\n            ticks: '',\r\n            side: 'bottom',\r\n            gridcolor: '#575656'\r\n        },\r\n        yaxis: {\r\n            title: {\r\n                text: '$M$',\r\n                standoff: 15,\r\n            },\r\n            ticks: '',\r\n            ticksuffix: ' ',\r\n            automargin: true,\r\n            gridcolor: '#575656',\r\n        },\r\n        paper_bgcolor: '#222',\r\n        plot_bgcolor: '#222',\r\n        font: {\r\n            color: '#eee'\r\n        },\r\n        autosize: false,\r\n        width: 800,\r\n        height: 800,\r\n        margin: {\r\n            l: 50,\r\n            r: 50,\r\n            b: 100,\r\n            t: 100,\r\n            pad: 4\r\n        },\r\n    };\r\n    \r\n    let costMatrix_D = {\r\n        z: math.transpose(costMat),\r\n        type: 'heatmap',\r\n        colorscale: 'Greys',\r\n        name: 'D',\r\n    };\r\n\r\n    let path_P = {\r\n        x: path.map(e => e[0]),\r\n        y: path.map(e => e[1]),\r\n        type: 'scatter',\r\n        name: 'P',\r\n        hoverlabel: {\r\n            font: {\r\n                color: '#eab933'\r\n            }\r\n        }\r\n    };\r\n    \r\n    let data = [costMatrix_D, path_P]\r\n    \r\n    Plotly.newPlot('path', data, layout, {scrollZoom: false});\r\n\r\n}\r\n\r\nfunction delay(time) {\r\n    return new Promise(resolve => setTimeout(resolve, time));\r\n  }\r\n\r\n// For MIDI length display in console\r\nlet convertHMS = (value) => {\r\n    const sec = parseInt(value, 10); // convert value to number if it's string\r\n    let hours   = Math.floor(sec / 3600); // get hours\r\n    let minutes = Math.floor((sec - (hours * 3600)) / 60); // get minutes\r\n    let seconds = sec - (hours * 3600) - (minutes * 60); //  get seconds\r\n    // add 0 if value < 10; Example: 2 => 02\r\n    if (hours   < 10) {hours   = \"0\"+hours;}\r\n    if (minutes < 10) {minutes = \"0\"+minutes;}\r\n    if (seconds < 10) {seconds = \"0\"+seconds;}\r\n    return minutes+':'+seconds; // Return is MM : SS\r\n}"],"names":[],"version":3,"file":"index.9b4c3e06.js.map","sourceRoot":"/__parcel_source_root/"}